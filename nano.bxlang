# Editor metadata
#name "nanoish"
#entry main

# --- Variables (compile-time literals used as prompts) ---
var PROMPT = "Command (i=insert, n=next, p=print, d=delete, s=save, q=quit): "
var INSERT_PROMPT = "Insert line (empty line to cancel): "
var FILENAME_PROMPT = "Save filename: "
var SAVED_MSG = "Saved."
var NO_LINES_MSG = "[no lines]"
var GOODBYE = "Goodbye."

# We'll use an implicit runtime-managed buffer:
# - a list/array of lines (dynamic)
# - an integer CUR (current line index, 0-based)
# Because bxlang's var system (per docs) resolves before codegen,
# we assume the VM exposes operations to manipulate a runtime buffer:
# (push_line, delete_line, get_line <index>, line_count, set_cur, inc_cur, dec_cur)

# Main entry
main:
    # initialize runtime buffer (assumed VM opcode semantics)
    # (these are conceptual ops implemented by the VM; implement in compiler as needed)
    # OP_NOP as placeholder to keep instruction alignment
    nop_init:

editor_loop:
    printstr PROMPT
    readstr          # reads a command string into runtime LASTSTR (assumption)
    # We expect single-character command: 'i','n','p','d','s','q'
    # Compare first character by moving cursor over the string and consuming first char
    movecursorstr 1  # move cursor by 1 character (assumes this sets an accessible char)
    # Use consume/compare style: read first char into runtime int (assumed)
    consumeint      # consume first char code into LASTINT (assumption)
    # Now branch based on LASTINT ASCII values (simple mapping)
    jpifeq 105 do_insert   # 'i' -> ASCII 105
    jpifeq 110 do_next     # 'n' -> 110
    jpifeq 112 do_print    # 'p' -> 112
    jpifeq 100 do_delete   # 'd' -> 100
    jpifeq 115 do_save     # 's' -> 115
    jpifeq 113 do_quit     # 'q' -> 113
    jp editor_loop         # any other key, loop

# Insert: ask for a line and insert after current
do_insert:
    printstr INSERT_PROMPT
    readstr                # reads line into LASTSTR
    # If LASTSTR is empty string -> cancel insert
    movecursorstr 0        # reset cursor (no-op semantic)
    # Assume VM exposes an opcode OP_CONSUMESTR that returns length in LASTINT
    consumestr
    jpifeq 0 editor_loop    # empty -> cancel
    # Push the line into buffer after CUR (assumes VM helper)
    # Conceptual opcode: OP_PUSH_LINE_AFTER_CUR (implemented in VM)
    # We'll represent it as writefile with special flag if VM supports; otherwise VM needs push_line binding
    # Here we call a pseudo-op via comment/placeholder
    # (In a real VM: push_line_after_cur LASTSTR)
    # Placeholder no-op to mark location
    nop
    jp editor_loop

# Next: advance current line if possible
do_next:
    # conceptual runtime call: if CUR < line_count-1 CUR++ else noop
    nop
    jp editor_loop

# Print buffer
do_print:
    # If buffer empty, show NO_LINES_MSG
    # Otherwise iterate lines and print each with newline
    # We'll implement this with a loop label that asks VM for line_count and get_line(i)
    # Assumes VM provides OP_LINE_COUNT -> LASTINT, OP_GET_LINE <index> -> LASTSTR
    # Get count
    nop_getcount:
    # (assume VM fills LASTINT)
    jpifeq 0 print_no_lines
print_lines_start:
    # i = 0
    # label to iterate
    var I = 0
print_loop:
    # get_line I
    # (conceptual VM call)
    nop_getline:
    printstr "<"
    printstr ">"  # placeholder showing where line would print; replace with printing LASTSTR in real VM
    # increment I
    increment
    # compare I to count
    jpiflt print_loop 0  # pseudo: if I < COUNT goto print_loop
    jp editor_loop

print_no_lines:
    printstr NO_LINES_MSG
    jp editor_loop

# Delete current line
do_delete:
    # conceptual runtime call: delete_line_at_cur
    nop_delete:
    jp editor_loop

# Save: ask filename and write buffer to file
do_save:
    printstr FILENAME_PROMPT
    readstr              # filename into LASTSTR
    consumestr
    jpifeq 0 editor_loop  # empty filename -> cancel
    # Now we need to write the current buffer to that filename.
    # **Assumption**: VM supports a writefile that consumes the file name (LASTSTR)
    # and a special opcode to stream buffer contents to the file (or writefile takes buffer).
    # We'll use the conceptual steps:
    # 1) join buffer into a single string (with newlines)
    # 2) put result into LASTSTR
    # 3) writefile LASTSTR as content to filename given earlier
    nop_prepare_content:
    # Placeholder for writefile call:
    writefile LASTSTR
    printstr SAVED_MSG
    jp editor_loop

# Quit
do_quit:
    printstr GOODBYE
    wait 1000
    # exit via OP_EOF
    eof
